evaluation period is for 4 years (2015-2018) #
# this period ends 1 year before end of simulation (2019)#
# there are some simulations that end Dec 2017, so evaluation period#
# ends Dec 2016 (2 years)#
# HIV first introduced into population in 1980#
#
demes <- c('I0', 'J0', 'K0', 'I1', 'J1', 'K1', 'I2', 'J2', 'K2')#
#
# I = acute, J = asymptomatic, K = chronic; S = susceptible#
# 0 = source population, 1 = main regional population, 2 = high risk minority population#
# mixing rates - NOTE rho is now the proportion reserved for contacts OUTSIDE of group#
p11 <- '((1-parms$rho1) * parms$c1*(S1+I1+J1+K1)*(1-parms$rho1) / (parms$c1*(S1+I1+J1+K1)*(1-parms$rho1) + parms$c2*(S2+I2+J2+K2)*(1-parms$rho2)))'#
p12 <- '(parms$rho1 + (1-parms$rho1) * parms$c2*(S2+I2+J2+K2)*(1-parms$rho2) / (parms$c1*(S1+I1+J1+K1)*(1-parms$rho1) + parms$c2*(S2+I2+J2+K2)*(1-parms$rho2)))'#
p21 <- '(parms$rho2 + (1-parms$rho2) * parms$c1*(S1+I1+J1+K1)*(1-parms$rho1) / (parms$c1*(S1+I1+J1+K1)*(1-parms$rho1) + parms$c2*(S2+I2+J2+K2)*(1-parms$rho2)))'#
p22 <- '((1-parms$rho2) * parms$c2*(S2+I2+J2+K2)*(1-parms$rho2) / (parms$c1*(S1+I1+J1+K1)*(1-parms$rho1) + parms$c2*(S2+I2+J2+K2)*(1-parms$rho2)))'#
#
# birth rates#
births <- rbind(#
	c('parms$z*parms$beta1*parms$c1*I0/(S0+I0+J0+K0)*S0', '0', '0',  #
	  '0', '0', '0',  #
	  '0', '0', '0'),  # I0 ->#
	c('parms$z*parms$beta2*parms$c1*J0/(S0+I0+J0+K0)*S0', '0', '0',  #
	  '0', '0', '0',  #
	  '0', '0', '0'),  # J0 ->#
	c('parms$z*parms$beta3*parms$c1*K0/(S0+I0+J0+K0)*S0', '0', '0',  #
	  '0', '0', '0',  #
	  '0', '0', '0'),  # K0 ->#
	c('0', '0', '0',#
	  paste(sep='*', 'parms$z*parms$beta1*parms$c1', p11, 'I1/(S1+I1+J1+K1)*S1'), '0', '0', # I1 -> I1#
	  paste(sep='*', 'parms$z*parms$beta1*parms$c2', p21, 'I1/(S1+I1+J1+K1)*S2'), '0', '0'  # I1 -> I2#
	  ),#
	c('0', '0', '0',#
	  paste(sep='*', 'parms$z*parms$beta2*parms$c1', p11, 'J1/(S1+I1+J1+K1)*S1'), '0', '0', # J1 -> I1#
	  paste(sep='*', 'parms$z*parms$beta2*parms$c2', p21, 'J1/(S1+I1+J1+K1)*S2'), '0', '0'  # J1 -> I2#
	  ),#
	c('0', '0', '0',#
	  paste(sep='*', 'parms$z*parms$beta3*parms$c1', p11, 'K1/(S1+I1+J1+K1)*S1'), '0', '0', # K1 -> I1#
	  paste(sep='*', 'parms$z*parms$beta3*parms$c2', p21, 'K1/(S1+I1+J1+K1)*S2'), '0', '0' # K1 -> I2#
	  ),#
	c('0', '0', '0',#
	  paste(sep='*', 'parms$z*parms$beta1*parms$c1', p12, 'I2/(S2+I2+J2+K2)*S1'), '0', '0', # I2 -> I1#
	  paste(sep='*', 'parms$z*parms$beta1*parms$c2', p22, 'I2/(S2+I2+J2+K2)*S2'), '0', '0' # I2 -> I2#
	  ),#
	c('0', '0', '0', #
	  paste(sep='*', 'parms$z*parms$beta2*parms$c1', p12, 'J2/(S2+I2+J2+K2)*S1'), '0', '0', # J2 -> J1#
	  paste(sep='*', 'parms$z*parms$beta2*parms$c2', p22, 'J2/(S2+I2+J2+K2)*S2'), '0', '0' # J2 -> J2#
	  ),#
	c('0', '0', '0',#
	  paste(sep='*', 'parms$z*parms$beta3*parms$c1', p12, 'K2/(S2+I2+J2+K2)*S1'), '0', '0', # K2 -> K1#
	  paste(sep='*', 'parms$z*parms$beta3*parms$c2', p22, 'K2/(S2+I2+J2+K2)*S2'), '0', '0' # K2 -> K2#
	  )#
)#
#
rownames(births)=colnames(births) <- demes#
#
# migration rates (transition from acute to chronic, not spatial migration)#
# note constant term is used to allow for early migration from source to sink while#
#  infected population in sink is zero#
migrations <- rbind(#
           c('0', 'parms$alpha1*I0', '0', '(parms$mig*I1 + 1e-4) * I0/(S0+I0+J0+K0)', '0', '0', '0', '0', '0'), # I0->J0#
           c('0', '0', 'parms$alpha2*J0', '0', 'parms$mig*J1*J0/(S0+I0+J0+K0)', '0', '0', '0', '0'), # J0->K0#
           c('0', '0', '0', '0', '0', '0', '0', '0', '0'),  #
           c('0', '0', '0', '0', 'parms$alpha1*I1', '0', '0', '0', '0'), # I1->J1#
           c('0', '0', '0', '0', '0', 'parms$alpha2*J1', '0', '0', '0'), # J1->K1#
           c('0', '0', '0', '0', '0', '0', '0', '0', '0'),#
           c('0', '0', '0', '0', '0', '0', '0', 'parms$alpha1*I2', '0'), # I2->J2#
           c('0', '0', '0', '0', '0', '0', '0', '0', 'parms$alpha2*J2'), # J2->K2#
           c('0', '0', '0', '0', '0', '0', '0', '0', '0')#
)#
rownames(migrations)=colnames(migrations) <- demes#
#
# death rates#
deaths <- c(#
	'parms$mu*I0', 'parms$mu*J0', '(parms$mu+parms$gamma)*K0', #
	'parms$mu*I1', 'parms$mu*J1', '(parms$mu+parms$gamma)*K1', #
	'parms$mu*I2', 'parms$mu*J2', '(parms$mu+parms$gamma)*K2'#
)#
names(deaths) <- demes#
# dynamics of susceptible class#
nonDemeDynamics <- c(#
	'-parms$mu*S0 + parms$mu*(S0+I0+J0+K0) + parms$gamma*K0 - S0*parms$c1*parms$z*(parms$beta1*I0+parms$beta2*J0+parms$beta3*K0)/(S0+I0+J0+K0) + parms$mig*(I1*I0+J1*J0)/(S0+I0+J0+K0)', #
	paste(sep='', '-parms$mu*S1 + parms$lam*S1 + parms$mu*(S1+I1+J1+K1) + parms$gamma*K1 - S1*parms$c1*parms$z*(', p11, #
	  '*(parms$beta1*I1 + parms$beta2*J1 + parms$beta3*K1)/(S1+I1+J1+K1) + ', p12, #
	  '*(parms$beta1*I2 + parms$beta2*J2 + parms$beta3*K2)/(S2+I2+J2+K2))'),#
	paste(sep='', '-parms$mu*S2 + parms$lam*S2 + parms$mu*(S2+I2+J2+K2) + parms$gamma*K2 - S2*parms$c2*parms$z*(', p21, #
	  '*(parms$beta1*I1 + parms$beta2*J1 + parms$beta3*K1)/(S1+I1+J1+K1) + ', p22, #
	  '*(parms$beta1*I2 + parms$beta2*J2 + parms$beta3*K2)/(S2+I2+J2+K2))')#
)#
#
names(nonDemeDynamics) <- c('S0', 'S1', 'S2')#
# initialize population sizes#
N0=1E6#
S0=N0-1; I0=1; J0=0; K0=0#
N1=1E4; p=0.05#
S1=N1*(1-p); I1=0; J1=0; K1=0#
S2=N1*p; I2=0; J2=0; K2=0#
x0 = c(I0=I0, J0=J0, K0=K0, #
	I1=I1, J1=J1, K1=K1, #
	I2=I2, J2=J2, K2=K2, S0=S0, S1=S1, S2=S2)#
#
## default settings#
nreps = 1#
fgyResolution = 500.  # large value gives smaller time step#
integrationMethod = 'rk4'#
t.end = 40.*52  # weeks#
n.tips = 200#
#
sampleTimes <- rep(t.end, times=n.tips)#
maxSampleTime <- max(sampleTimes)#
#
# numerical solution of ODE system#
require(rcolgem)#
#
eval.period <- 5*52.  # weeks#
t0 <- 0#
t1 <- (maxSampleTime-eval.period) / 2#
fgyRes.1 <- round(fgyResolution * (t1-t0) / maxSampleTime)#
#
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.025, beta1=0.03, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)#
#
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)
use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
sanity checks#
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.0025, beta1=0.03, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
sanity checks#
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
1/0.0025
52/0.0025
1/0.0025 / 52
1/0.002 / 52
1/0.001 / 52
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.03, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)
use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
head(df)
n <- apply(df[,2:ncol(df)], 1, sum)
n
n <- apply(df[,c(5:7,13)], 1, sum)
n
n <- apply(df[,c(5:7,12)], 1, sum)
n
plot(n)
plot(n, type='l')
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.002, beta1=0.03, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
n <- apply(df[,c(5:7,12)], 1, sum)
plot(n, type='l')
?diff
diff(n, 1)
length(n)
n[2]-n[1]
n[62]-n[61]
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.03, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
n <- apply(df[,c(5:7,12)], 1, sum)
n
head(df)
sampleStates <- matrix(0, nrow=n.tips, ncol=length(demes))#
colnames(sampleStates) <- demes#
rownames(sampleStates) <- 1:n.tips#
#
demes.t.end <- tfgy.3[[4]][[1]]#
sampled.demes <- which(!grepl("0$", names(demes.t.end)))#
demes.sample <- sample(rep(sampled.demes, times=round(demes.t.end[sampled.demes])), size=n.tips)#
#demes.sample <- sample(rep(1:length(demes), times=round(demes.t.end)), size=n.tips)#
sampleStates <- matrix(0, nrow=n.tips, ncol=length(demes))#
colnames(sampleStates) <- demes#
for (i in 1:n.tips) {#
	sampleStates[i, demes.sample[i]] <- 1#
}#
rownames(sampleStates) <- paste(1:n.tips, demes.sample, sep='_')#
#
# reconstritute the entire ODE#
#y.times <- c(tfgy.3[[1]], tfgy.2[[1]], tfgy.1[[1]])#
# concatenation fails to get equal increments#
y.times <- rev(seq(0, maxSampleTime, length.out=fgyResolution))#
y.births <- c(tfgy.3[[2]], tfgy.2[[2]], tfgy.1[[2]])#
y.migrations <- c(tfgy.3[[3]], tfgy.2[[3]], tfgy.1[[3]])#
y.demeSizes <- c(tfgy.3[[4]], tfgy.2[[4]], tfgy.1[[4]])
dim(y.demeSizes)
length(y.demeSizes)
y.demeSizes[1,]
y.demeSizes[1]
n
n[1] * exp(0.025)
t3-t2
n[1] * exp(0.025*260)
260/52
n[1] * exp(0.0025*260)
n[1] * exp(0.0025*5)
n[1] * exp(0.025*5)
trees <- simulate.binary.dated.tree.fgy( y.times, y.births, y.migrations, y.demeSizes, sampleTimes, sampleStates, integrationMethod = integrationMethod, n.reps=nreps)
plot(trees[[1]])
dynamics of susceptible class#
nonDemeDynamics <- c(#
	'-parms$mu*S0 + +parms$lam*S0 + parms$mu*(S0+I0+J0+K0) + parms$gamma*K0 - S0*parms$c1*parms$z*(parms$beta1*I0+parms$beta2*J0+parms$beta3*K0)/(S0+I0+J0+K0) + parms$mig*(I1*I0+J1*J0)/(S0+I0+J0+K0)', #
	paste(sep='', '-parms$mu*S1 + parms$lam*S1 + parms$mu*(S1+I1+J1+K1) + parms$gamma*K1 - S1*parms$c1*parms$z*(', p11, #
	  '*(parms$beta1*I1 + parms$beta2*J1 + parms$beta3*K1)/(S1+I1+J1+K1) + ', p12, #
	  '*(parms$beta1*I2 + parms$beta2*J2 + parms$beta3*K2)/(S2+I2+J2+K2))'),#
	paste(sep='', '-parms$mu*S2 + parms$lam*S2 + parms$mu*(S2+I2+J2+K2) + parms$gamma*K2 - S2*parms$c2*parms$z*(', p21, #
	  '*(parms$beta1*I1 + parms$beta2*J1 + parms$beta3*K1)/(S1+I1+J1+K1) + ', p22, #
	  '*(parms$beta1*I2 + parms$beta2*J2 + parms$beta3*K2)/(S2+I2+J2+K2))')#
)
names(nonDemeDynamics) <- c('S0', 'S1', 'S2')
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.03, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
sanity checks#
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
which deme was each tip sampled from#
sampleStates <- matrix(0, nrow=n.tips, ncol=length(demes))#
colnames(sampleStates) <- demes#
rownames(sampleStates) <- 1:n.tips#
#
demes.t.end <- tfgy.3[[4]][[1]]#
sampled.demes <- which(!grepl("0$", names(demes.t.end)))#
demes.sample <- sample(rep(sampled.demes, times=round(demes.t.end[sampled.demes])), size=n.tips)#
#demes.sample <- sample(rep(1:length(demes), times=round(demes.t.end)), size=n.tips)#
sampleStates <- matrix(0, nrow=n.tips, ncol=length(demes))#
colnames(sampleStates) <- demes#
for (i in 1:n.tips) {#
	sampleStates[i, demes.sample[i]] <- 1#
}#
rownames(sampleStates) <- paste(1:n.tips, demes.sample, sep='_')
reconstritute the entire ODE#
#y.times <- c(tfgy.3[[1]], tfgy.2[[1]], tfgy.1[[1]])#
# concatenation fails to get equal increments#
y.times <- rev(seq(0, maxSampleTime, length.out=fgyResolution))#
y.births <- c(tfgy.3[[2]], tfgy.2[[2]], tfgy.1[[2]])#
y.migrations <- c(tfgy.3[[3]], tfgy.2[[3]], tfgy.1[[3]])#
y.demeSizes <- c(tfgy.3[[4]], tfgy.2[[4]], tfgy.1[[4]])#
#
trees <- simulate.binary.dated.tree.fgy( y.times, y.births, y.migrations, y.demeSizes, sampleTimes, sampleStates, integrationMethod = integrationMethod, n.reps=nreps)#
plot(trees[[1]])
'multiPhylo' -> class(trees)
output.nwk <- 'test-pangea-1.nwk'
write.tree(trees, file=output.nwk, append=FALSE)
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.05, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.025, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.05/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.025, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=5.0, mig=0.03/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
sanity checks#
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.025, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=3.0, mig=0.03/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.025, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=0.5, c2=2.0, mig=0.03/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.025, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=2.0, mig=0.03/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
sanity checks#
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.025, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=0.8, c2=2.0, mig=0.03/52, z=1)
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
sanity checks#
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
lam = growth rate in target population #
parms <- list(alpha1=0.01, alpha2=0.001, gamma=1/520., mu=1/3640., lam=0.001, beta1=0.025, beta2=0.00084, beta3=0.02, rho1=0.1, rho2=0.9, c1=1.0, c2=2.0, mig=0.03/52, z=1)#
#
tfgy.1 <- make.fgy(t0, t1, births, deaths, nonDemeDynamics, x0, migrations=migrations, parms=parms, fgyResolution=fgyRes.1, integrationMethod=integrationMethod)#
#
# use state of system at last time point to initialize next interval#
x1 <- tfgy.1[[5]][fgyRes.1, 2:ncol(tfgy.1[[5]])]#
t2 <- maxSampleTime-eval.period#
fgyRes.2 <- round(fgyResolution * (t2-t1) / maxSampleTime)#
parms$z <- 1.3#
#
tfgy.2 <- make.fgy(t1, t2, births, deaths, nonDemeDynamics, x1, migrations=migrations, parms=parms, fgyResolution=fgyRes.2, integrationMethod=integrationMethod)#
#
x2 <- tfgy.2[[5]][fgyRes.2, 2:ncol(tfgy.2[[5]])]#
t3 <- maxSampleTime#
fgyRes.3 <- fgyResolution - fgyRes.1 - fgyRes.2#
parms$z <- 0.5#
#
tfgy.3 <- make.fgy(t2, t3, births, deaths, nonDemeDynamics, x2, migrations=migrations, parms=parms, fgyResolution=fgyRes.3, integrationMethod=integrationMethod)
sanity checks#
par(mfrow=c(3,1), mar=c(5,5,0,2))#
#
mat <- rbind(c(11,2,3,4), c(12,5,6,7), c(13,8,9,10))#
for (i in c(1:nrow(mat))) {#
	x <- mat[i,]#
	df <- tfgy.1[[5]]#
	t <- df[,1] / 52.#
	plot(t, df[,x[1]], ylim=c(0, max(df[,x[1]])), type='l', col='forestgreen', lwd=2, xlim=c(0, maxSampleTime)/52.)#
	lines(t, df[,x[2]], col='red', lwd=2)#
	lines(t, df[,x[3]], col='orange', lwd=2)#
	lines(t, df[,x[4]], col='black', lwd=2)#
	df <- tfgy.2[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=2, lty=2)#
	lines(t, df[,x[2]], col='red', lwd=2, lty=2)#
	lines(t, df[,x[3]], col='orange', lwd=2, lty=2)#
	lines(t, df[,x[4]], col='black', lwd=2, lty=2)#
	df <- tfgy.3[[5]]#
	t <- df[,1] / 52.#
	lines(t, df[,x[1]], col='forestgreen', lwd=1, lty=3)#
	lines(t, df[,x[2]], col='red', lwd=1, lty=3)#
	lines(t, df[,x[3]], col='orange', lwd=1, lty=3)#
	lines(t, df[,x[4]], col='black', lwd=1, lty=3)#
}
which deme was each tip sampled from#
sampleStates <- matrix(0, nrow=n.tips, ncol=length(demes))#
colnames(sampleStates) <- demes#
rownames(sampleStates) <- 1:n.tips#
#
demes.t.end <- tfgy.3[[4]][[1]]#
sampled.demes <- which(!grepl("0$", names(demes.t.end)))#
demes.sample <- sample(rep(sampled.demes, times=round(demes.t.end[sampled.demes])), size=n.tips)#
#demes.sample <- sample(rep(1:length(demes), times=round(demes.t.end)), size=n.tips)#
sampleStates <- matrix(0, nrow=n.tips, ncol=length(demes))#
colnames(sampleStates) <- demes#
for (i in 1:n.tips) {#
	sampleStates[i, demes.sample[i]] <- 1#
}#
rownames(sampleStates) <- paste(1:n.tips, demes.sample, sep='_')
y.times <- c(tfgy.3[[1]], tfgy.2[[1]], tfgy.1[[1]])#
# concatenation fails to get equal increments#
y.times <- rev(seq(0, maxSampleTime, length.out=fgyResolution))#
y.births <- c(tfgy.3[[2]], tfgy.2[[2]], tfgy.1[[2]])#
y.migrations <- c(tfgy.3[[3]], tfgy.2[[3]], tfgy.1[[3]])#
y.demeSizes <- c(tfgy.3[[4]], tfgy.2[[4]], tfgy.1[[4]])#
#
trees <- simulate.binary.dated.tree.fgy( y.times, y.births, y.migrations, y.demeSizes, sampleTimes, sampleStates, integrationMethod = integrationMethod, n.reps=nreps)
plot(trees[[1]])
'multiPhylo' -> class(trees)
output.nwk <- 'test-pangea-1.nwk'
write.tree(trees, file=output.nwk, append=FALSE)
nreps <- 10
trees <- simulate.binary.dated.tree.fgy( y.times, y.births, y.migrations, y.demeSizes, sampleTimes, sampleStates, integrationMethod = integrationMethod, n.reps=nreps)
'multiPhylo' -> class(trees)
output.nwk <- 'test-pangea-1.nwk'
write.tree(trees, file=output.nwk, append=FALSE)
scueal <- read.csv('~/Desktop/bootcamp-data/upload.11613936232337.1_SCUEAL_report.csv', header=T)
head(scueal)
scueal <- read.table('~/Desktop/bootcamp-data/upload.11613936232337.1_SCUEAL_report.csv', header=T, sep='\t')
scueal <- read.table('~/Desktop/bootcamp-data/upload.11613936232337.1_SCUEAL_report.tsv', header=T, sep='\t')
head(scueal)
summary(scueal)
scueal$Name
scueal$Name[order(scueal$recom, decreasing=TRUE)]
scueal$Name[order(scueal$Support.for.recombination, decreasing=TRUE)]
plot(scueal$Support.for.recombination)
abline(h=0.95)
which(scueal$Support.for.recombination > 0.95)
scueal$Name[which(scueal$Support.for.recombination > 0.95)]
which(scueal$Support.for.recombination < 0.05)
abline(h=0.05)
abline(h=0.02)
which(scueal$Support.for.recombination < 0.02)
temp <- which(scueal$Support.for.recombination < 0.02)
sample(temp, 17)
index <- c(22, 77, 110, 84, 50, 47, 35, 81, 17, 105, 65, 4, 60, 94, 6, 75, 67, 14)
scueal$Subtype
scueal[48,]
48 %in% index
index
sort(index)
fasta <- cbind(scueal$Name[index], scueal$Sequence[index])
fasta
fasta <- cbind(as.character(scueal$Name)[index], as.character(scueal$Sequence)[index])
fasta
fasta[1,]
fasta <- data.frame(name=as.character(scueal$Name)[index], seq=as.character(scueal$Sequence)[index])
head(fasta)
dim(fasta)
write.csv(fasta, file='~/Desktop/bootcamp-data/HIV1_C_pol_ZA.n20.fa', quote=FALSE)
index
length(index)
index <- c(22, 77, 110, 84, 50, 47, 35, 81, 17, 105, 65, 4, 60, 94, 6, 75, 67, 14, 86, 23)
fasta <- data.frame(name=as.character(scueal$Name)[index], seq=as.character(scueal$Sequence)[index])
write.csv(fasta, file='~/Desktop/bootcamp-data/HIV1_C_pol_ZA.n20.fa', quote=FALSE)
scueal[index,]
scueal$Breakpoints[index,]
scueal$Breakpoints[index]
hist(scueal$Support.for.recombination)
scueal
tsv <- read.table('~/Documents/Slides/IAS2015/bootcamp-data/upload.11613936232337.1_SCUEAL_report.tsv', sep='\t', header=T)
tsv[1,]
summary(tsv)
summary(tsv$Break)
foo <- tsv[order(tsv$Support.for.recombination)]
foo <- tsv[order(tsv$Support.for.recombination),]
foo[1:5,]
foo <- tsv[order(tsv$Support.for.recombination, dec=T),]
foo <- tsv[order(tsv$Support.for.recombination, decreasing=T),]
foo[1:5,]
hiv <- read.csv('~/Downloads/sh.dyn.aids.zs_Indicator_en_csv_v2/sh.dyn.aids.zs_Indicator_en_csv_v2.csv', header=T)
head(hiv)
sums <- apply(hiv, 2, function(x) sum(x, na.rm=T))
summary(hiv)
names(hiv)
sums <- apply(hiv[,35:ncol(hiv)], 2, function(x) sum(x, na.rm=T))
sums
sums <- apply(hiv[,35:(ncol(hiv)-2)], 2, function(x) sum(x, na.rm=T))
sums
plot(sums)
row.sums <- apply(hiv[,35:(ncol(hiv)-2)], 1, function(x) sum(x, na.rm=T))
row.sums
plot(row.sums)
plot(row.sums, type='n')
text(1:length(row.sums), row.sums, hiv$Country.Code)
plot(row.sums, type='n')
text(1:length(row.sums), row.sums, hiv$Country.Code, cex=0.8)
which(hiv$Country.Code=='CAN')
plot(hiv[34, 35:40])
hiv[34,]
plot(sums, type='b')
plot(sums, type='b', ylab='HIV Prevalence, ages 15-49')
which(hiv$Country.Code=='BWA')
hiv[32,]
plot(sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20)
plot(sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=2)
plot(sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5)
plot(sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red')
hiv[1,]
plot(x=1990:2013, y=sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red')
plot(x=1990:2013, y=sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')
par(mar=c(5,5,2,2))
plot(x=1990:2013, y=sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')
text(x=2005, y=170, label='Source: UNAIDS', cex=0.8)
text(x=2009, y=170, label='Source: UNAIDS', cex=0.8)
text(x=2009, y=150, label='Source: UNAIDS', cex=0.8)
BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')#
#
text(x=2009, y=150, label='Source: UNAIDS', cex=0.8)
text(x=2009, y=150, label='Source: World Bank, UNAIDS', cex=0.8)
text(x=2008, y=150, label='Source: World Bank, UNAIDS', cex=0.8)
BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')#
#
text(x=2008, y=150, label='Source: World Bank, UNAIDS', cex=0.8)
text(x=2008, y=145, label='Source: World Bank, UNAIDS', cex=0.8)
text(x=2008, y=140, label='Source: World Bank, UNAIDS', cex=0.8)
BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=sums, type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')#
#
text(x=2008, y=140, label='Source: World Bank, UNAIDS', cex=0.8)
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence, ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b')
hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)]
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year')#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(5,30))
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(5,30))#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(4,30))#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)
text(x=2008, y=140, label='Source: World Bank, UNAIDS', cex=0.8)
text(x=2008, y=5, label='Source: World Bank, UNAIDS', cex=0.8)
text(x=2009, y=15, label='Botswana')
text(x=2009, y=15, label='Botswana', cex=0.8)
text(x=2009, y=15, label='Botswana', cex=0.8, col='red')
text(x=2009, y=20, label='Botswana', cex=0.8, col='red')
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(4,30))#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
#
text(x=2008, y=5, label='Source: World Bank, UNAIDS', cex=0.8)
text(x=2009, y=21.5, label='Botswana', cex=0.8, col='red')
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(4,30))#
text(x=2009, y=21.5, label='Botswana', cex=0.8, col='red')
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)
text(x=2009, y=27, label='Swaziland', cex=0.8, col='red')
text(x=2009, y=27, label='Swaziland', cex=0.8, col='blue')
text(x=2009, y=28, label='Swaziland', cex=0.8, col='blue')
text(x=2010, y=28, label='Swaziland', cex=0.8, col='blue')
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(4,30))#
text(x=2009, y=21.5, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)
text(x=2009, y=15, label='Zimbabwe', cex=0.8, col='forestgreen')
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(4,30))#
text(x=2009, y=21.5, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=4, label='Source: World Bank, UNAIDS', cex=0.8)
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(4,30))#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=4, label='Source: World Bank, UNAIDS', cex=0.8)
BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(1,30))#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=4, label='Source: World Bank, UNAIDS', cex=0.8)
who <- read.csv('~/git/papers/uwo2014/images/xmart.csv', header=T)
who[1,]
summary(hiv)
summary(who)
??shapefile
require(maptools)
??maptools
http://data.worldbank.org/indicator/SH.DYN.AIDS.ZS#
# Prevalence of HIV refers to the percentage of people ages 15-49 who are infected with HIV.#
# UNAIDS estimates.#
#
hiv <- read.csv('~/Downloads/sh.dyn.aids.zs_Indicator_en_csv_v2/sh.dyn.aids.zs_Indicator_en_csv_v2.csv', header=T)#
#
sums <- apply(hiv[,35:(ncol(hiv)-2)], 2, function(x) sum(x, na.rm=T))#
#
row.sums <- apply(hiv[,35:(ncol(hiv)-2)], 1, function(x) sum(x, na.rm=T))#
#
plot(row.sums, type='n')#
text(1:length(row.sums), row.sums, hiv$Country.Code)#
#
# BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(1,30))#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=2, label='Source: World Bank, UNAIDS', cex=0.8)#
###############
#
who <- read.csv('~/git/papers/uwo2014/images/xmart.csv', header=T)
hiv <- read.csv('~/git/papers/uwo2014/data/sh.dyn.aids.zs_Indicator_en_csv_v2/sh.dyn.aids.zs_Indicator_en_csv_v2.csv', header=T)
hiv <- read.csv('~/git/papers/uwo2014/images/sh.dyn.aids.zs_Indicator_en_csv_v2/sh.dyn.aids.zs_Indicator_en_csv_v2.csv', header=T)
hiv <- read.csv('~/git/papers/uwo2014/images/sh.dyn.aids.zs_Indicator_en_csv_v2.csv', header=T)
sums <- apply(hiv[,35:(ncol(hiv)-2)], 2, function(x) sum(x, na.rm=T))#
#
row.sums <- apply(hiv[,35:(ncol(hiv)-2)], 1, function(x) sum(x, na.rm=T))#
#
plot(row.sums, type='n')#
text(1:length(row.sums), row.sums, hiv$Country.Code)#
#
# BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(1,30))#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=2, label='Source: World Bank, UNAIDS', cex=0.8)#
###############
#
who <- read.csv('~/git/papers/uwo2014/images/xmart.csv', header=T)
http://data.worldbank.org/indicator/SH.DYN.AIDS.ZS#
# Prevalence of HIV refers to the percentage of people ages 15-49 who are infected with HIV.#
# UNAIDS estimates.#
#
hiv <- read.csv('~/git/papers/uwo2014/images/sh.dyn.aids.zs_Indicator_en_csv_v2.csv', header=T)#
#
sums <- apply(hiv[,35:(ncol(hiv)-2)], 2, function(x) sum(x, na.rm=T))#
#
row.sums <- apply(hiv[,35:(ncol(hiv)-2)], 1, function(x) sum(x, na.rm=T))#
#
plot(row.sums, type='n')#
text(1:length(row.sums), row.sums, hiv$Country.Code)#
#
# BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(1,30))#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=1, label='Source: World Bank, UNAIDS', cex=0.8)#
###############
#
who <- read.csv('~/git/papers/uwo2014/images/xmart.csv', header=T)
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(1,30), cex.lab=1.5)
http://data.worldbank.org/indicator/SH.DYN.AIDS.ZS#
# Prevalence of HIV refers to the percentage of people ages 15-49 who are infected with HIV.#
# UNAIDS estimates.#
#
hiv <- read.csv('~/git/papers/uwo2014/images/sh.dyn.aids.zs_Indicator_en_csv_v2.csv', header=T)#
#
sums <- apply(hiv[,35:(ncol(hiv)-2)], 2, function(x) sum(x, na.rm=T))#
#
row.sums <- apply(hiv[,35:(ncol(hiv)-2)], 1, function(x) sum(x, na.rm=T))#
#
plot(row.sums, type='n')#
text(1:length(row.sums), row.sums, hiv$Country.Code)#
#
# BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(1,30), cex.lab=1.5)#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=1, label='Source: World Bank, UNAIDS', cex=0.8)#
###############
#
who <- read.csv('~/git/papers/uwo2014/images/xmart.csv', header=T)
BWA, SWZ, ZWE#
par(mar=c(5,5,2,2))#
plot(x=1990:2013, y=hiv[which(hiv$Country.Code=='BWA'), 35:(ncol(hiv)-2)], type='b', ylab='HIV Prevalence (%), ages 15-49', pch=20, cex=1.5, col='red', xlab='Year', ylim=c(1,30), cex.lab=1.2)#
text(x=2009, y=22, label='Botswana', cex=0.8, col='red')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='SWZ'), 35:(ncol(hiv)-2)], type='b', col='blue', pch=20, cex=1.5)#
text(x=2010, y=28.5, label='Swaziland', cex=0.8, col='blue')#
#
lines(x=1990:2013, y=hiv[which(hiv$Country.Code=='ZWE'), 35:(ncol(hiv)-2)], type='b', col='forestgreen', pch=20, cex=1.5)#
text(x=2009, y=14.5, label='Zimbabwe', cex=0.8, col='forestgreen')#
#
text(x=2008, y=1, label='Source: World Bank, UNAIDS', cex=0.8)#
###############
#
who <- read.csv('~/git/papers/uwo2014/images/xmart.csv', header=T)
library(ape)#
library(parallel)#
#
#source('ape.patches.R')#
source('include/rtt.R')#
source('include/test.R')#
source('include/raxml.R')#
#
trim <- function (x) gsub("^\\s+|\\s+$", "", x)#
extract_dates <- function(x) as.numeric(gsub("(.+)_([0-9\\.]+)$", "\\2", x, perl=T))#
#
n.simulated <- 50#
#
ml.tree <- function(i){#
	dna.file <- sprintf("__tmp%d.dna",i)#
	unlink(dna.file)#
#
	simenv.dna <- read.FASTA(sprintf("simulated/HIV_%d_out_TRUE.fas", i))#
	#simenv.dna <- read.dna(sprintf("simulated/HIV_SIM_%d.phy", i))#
	uid <- sample(1:length(names(simenv.dna)), length(names(simenv.dna)), replace=F)#
	# read.FASTA is buggy, and creates the DNABin structure incorrectly#
	# BUT, it's so broken that we can mess around with the names, then...#
	for(j in 1:length(names(simenv.dna))) { #
		# give each bin a unique name #
		names(simenv.dna)[j] <- sprintf("u%s_%s", uid[j], names(simenv.dna)[j])#
	}#
#
	# ... output a file (which works for some reason)#
	write.dna(simenv.dna, dna.file)#
	# and re-read it as a properly formatted DNA Bin#
	simenv.dna <- read.dna(dna.file)#
#
	tree <- raxml(simenv.dna, N=100, parsimony.seed=10000, bootstrap.seed=1000,threads=6)#
	write.tree(tree, sprintf("trees/HIV_ml_%d_out.nwk", i))#
#
	unlink(dna.file)#
	tree#
}#
#
trees.read <- function(base.path) {#
	ml.tree.read <- function(i, path){#
		read.tree(sprintf("%s/HIV_ml_%d_out.nwk", path, i))#
	}#
	mclapply(1:n.simulated, ml.tree.read, base.path)#
}#
#
hiv.rna.read <- function(){#
	trs <- dir('./7_ml_tree')[grep('_rna.nwk', dir('./7_ml_tree'))]#
	ml.tree.read <- function(tr) {#
		read.tree(paste('./7_ml_tree', tr, sep='/'))#
	}#
	lapply(trs, ml.tree.read)#
}#
#
trees <- mclapply(1:n.simulated, ml.tree, mc.cores=1)#
#trees <- hiv.rna.read()#
#trees <- trees.read("simulated/tree/")#
#
n.simulated <- length(trees)#
run_name <- "HIV RNA"#
species <- "Simulated"#
n.runs <- 100#
#
for(remove in c(1, 5, 10, 25)){#
	pdf(sprintf('%s_%d.pdf', run_name, remove), width=11.5, height=8.5)#
#
	mse <- rep(0, n.simulated*n.runs)#
	for(i in 1:n.simulated){#
		if(length(trees[[i]]$tip.label) <= remove) {#
			next#
		}#
		tip.dates <- extract_dates(trees[[i]]$tip.label)#
		r <- test.n.plot.rtt(trees[[i]], tip.dates, remove, name=sprintf("%s: %s-no.%d (Remove %d)", run_name, species, i, remove))#
		if(is.null(r)){#
			next#
		}#
		for(j in 1:n.runs) {#
			err  <- test.rtt(trees[[i]], tip.dates, remove)#
			if(!is.null(err)) {#
				mse[(j-1)*n.simulated + i] <- err#
			}#
		}#
	}#
#
	par(mfrow = c(1, 1))#
	mean_mse <- mean(mse)#
	hist(mse, breaks=100,  main="Histogram of MSE", sub=sprintf("(Average MSE [in red]: %s)", signif(mean_mse, digits=6)))#
	abline(v = mean_mse, col = "red", lwd = 2)#
	dev.off()#
}
setwd('~/git/cfe-papers/blind-dating/data/')#
#
library(ape)#
library(parallel)#
#
#source('ape.patches.R')#
source('include/rtt.R')#
source('include/test.R')#
source('include/raxml.R')#
#
trim <- function (x) gsub("^\\s+|\\s+$", "", x)#
extract_dates <- function(x) as.numeric(gsub("(.+)_([0-9\\.]+)$", "\\2", x, perl=T))#
#
n.simulated <- 50#
#
ml.tree <- function(i){#
	dna.file <- sprintf("__tmp%d.dna",i)#
	unlink(dna.file)#
#
	simenv.dna <- read.FASTA(sprintf("simulated/HIV_%d_out_TRUE.fas", i))#
	#simenv.dna <- read.dna(sprintf("simulated/HIV_SIM_%d.phy", i))#
	uid <- sample(1:length(names(simenv.dna)), length(names(simenv.dna)), replace=F)#
	# read.FASTA is buggy, and creates the DNABin structure incorrectly#
	# BUT, it's so broken that we can mess around with the names, then...#
	for(j in 1:length(names(simenv.dna))) { #
		# give each bin a unique name #
		names(simenv.dna)[j] <- sprintf("u%s_%s", uid[j], names(simenv.dna)[j])#
	}#
#
	# ... output a file (which works for some reason)#
	write.dna(simenv.dna, dna.file)#
	# and re-read it as a properly formatted DNA Bin#
	simenv.dna <- read.dna(dna.file)#
#
	tree <- raxml(simenv.dna, N=100, parsimony.seed=10000, bootstrap.seed=1000,threads=6)#
	write.tree(tree, sprintf("trees/HIV_ml_%d_out.nwk", i))#
#
	unlink(dna.file)#
	tree#
}#
#
trees.read <- function(base.path) {#
	ml.tree.read <- function(i, path){#
		read.tree(sprintf("%s/HIV_ml_%d_out.nwk", path, i))#
	}#
	mclapply(1:n.simulated, ml.tree.read, base.path)#
}#
#
hiv.rna.read <- function(){#
	trs <- dir('./7_ml_tree')[grep('_rna.nwk', dir('./7_ml_tree'))]#
	ml.tree.read <- function(tr) {#
		read.tree(paste('./7_ml_tree', tr, sep='/'))#
	}#
	lapply(trs, ml.tree.read)#
}#
#
trees <- mclapply(1:n.simulated, ml.tree, mc.cores=1)#
#trees <- hiv.rna.read()#
#trees <- trees.read("simulated/tree/")#
#
n.simulated <- length(trees)#
run_name <- "HIV RNA"#
species <- "Simulated"#
n.runs <- 100#
#
for(remove in c(1, 5, 10, 25)){#
	pdf(sprintf('%s_%d.pdf', run_name, remove), width=11.5, height=8.5)#
#
	mse <- rep(0, n.simulated*n.runs)#
	for(i in 1:n.simulated){#
		if(length(trees[[i]]$tip.label) <= remove) {#
			next#
		}#
		tip.dates <- extract_dates(trees[[i]]$tip.label)#
		r <- test.n.plot.rtt(trees[[i]], tip.dates, remove, name=sprintf("%s: %s-no.%d (Remove %d)", run_name, species, i, remove))#
		if(is.null(r)){#
			next#
		}#
		for(j in 1:n.runs) {#
			err  <- test.rtt(trees[[i]], tip.dates, remove)#
			if(!is.null(err)) {#
				mse[(j-1)*n.simulated + i] <- err#
			}#
		}#
	}#
#
	par(mfrow = c(1, 1))#
	mean_mse <- mean(mse)#
	hist(mse, breaks=100,  main="Histogram of MSE", sub=sprintf("(Average MSE [in red]: %s)", signif(mean_mse, digits=6)))#
	abline(v = mean_mse, col = "red", lwd = 2)#
	dev.off()#
}
setwd('/Users/art/git/cfe-papers/blind-dating/data/')
library(ape)
library(parallel)
setwd('/Users/art/git/cfe-papers/blind-dating/data/')#
#
library(ape)#
library(parallel)#
#
#source('ape.patches.R')#
source('include/rtt.R')#
source('include/test.R')#
source('include/raxml.R')#
#
trim <- function (x) gsub("^\\s+|\\s+$", "", x)#
extract_dates <- function(x) as.numeric(gsub("(.+)_([0-9\\.]+)$", "\\2", x, perl=T))#
#
n.simulated <- 50#
#
ml.tree <- function(i){#
	dna.file <- sprintf("__tmp%d.dna",i)#
	unlink(dna.file)#
#
	simenv.dna <- read.FASTA(sprintf("simulated/HIV_%d_out_TRUE.fas", i))#
	#simenv.dna <- read.dna(sprintf("simulated/HIV_SIM_%d.phy", i))#
	uid <- sample(1:length(names(simenv.dna)), length(names(simenv.dna)), replace=F)#
	# read.FASTA is buggy, and creates the DNABin structure incorrectly#
	# BUT, it's so broken that we can mess around with the names, then...#
	for(j in 1:length(names(simenv.dna))) { #
		# give each bin a unique name #
		names(simenv.dna)[j] <- sprintf("u%s_%s", uid[j], names(simenv.dna)[j])#
	}#
#
	# ... output a file (which works for some reason)#
	write.dna(simenv.dna, dna.file)#
	# and re-read it as a properly formatted DNA Bin#
	simenv.dna <- read.dna(dna.file)#
#
	tree <- raxml(simenv.dna, N=100, parsimony.seed=10000, bootstrap.seed=1000,threads=6)#
	write.tree(tree, sprintf("trees/HIV_ml_%d_out.nwk", i))#
#
	unlink(dna.file)#
	tree#
}#
#
trees.read <- function(base.path) {#
	ml.tree.read <- function(i, path){#
		read.tree(sprintf("%s/HIV_ml_%d_out.nwk", path, i))#
	}#
	mclapply(1:n.simulated, ml.tree.read, base.path)#
}#
#
hiv.rna.read <- function(){#
	trs <- dir('./7_ml_tree')[grep('_rna.nwk', dir('./7_ml_tree'))]#
	ml.tree.read <- function(tr) {#
		read.tree(paste('./7_ml_tree', tr, sep='/'))#
	}#
	lapply(trs, ml.tree.read)#
}#
#
trees <- mclapply(1:n.simulated, ml.tree, mc.cores=1)#
#trees <- hiv.rna.read()#
#trees <- trees.read("simulated/tree/")#
#
n.simulated <- length(trees)#
run_name <- "HIV RNA"#
species <- "Simulated"#
n.runs <- 100#
#
for(remove in c(1, 5, 10, 25)){#
	pdf(sprintf('%s_%d.pdf', run_name, remove), width=11.5, height=8.5)#
#
	mse <- rep(0, n.simulated*n.runs)#
	for(i in 1:n.simulated){#
		if(length(trees[[i]]$tip.label) <= remove) {#
			next#
		}#
		tip.dates <- extract_dates(trees[[i]]$tip.label)#
		r <- test.n.plot.rtt(trees[[i]], tip.dates, remove, name=sprintf("%s: %s-no.%d (Remove %d)", run_name, species, i, remove))#
		if(is.null(r)){#
			next#
		}#
		for(j in 1:n.runs) {#
			err  <- test.rtt(trees[[i]], tip.dates, remove)#
			if(!is.null(err)) {#
				mse[(j-1)*n.simulated + i] <- err#
			}#
		}#
	}#
#
	par(mfrow = c(1, 1))#
	mean_mse <- mean(mse)#
	hist(mse, breaks=100,  main="Histogram of MSE", sub=sprintf("(Average MSE [in red]: %s)", signif(mean_mse, digits=6)))#
	abline(v = mean_mse, col = "red", lwd = 2)#
	dev.off()#
}
setwd('/Users/art/git/cfe-papers/blind-dating/data/simulated/')#
#
library(ape)#
library(parallel)#
#
#source('ape.patches.R')#
source('include/rtt.R')#
source('include/test.R')#
source('include/raxml.R')#
#
trim <- function (x) gsub("^\\s+|\\s+$", "", x)#
extract_dates <- function(x) as.numeric(gsub("(.+)_([0-9\\.]+)$", "\\2", x, perl=T))#
#
n.simulated <- 50#
#
ml.tree <- function(i){#
	dna.file <- sprintf("__tmp%d.dna",i)#
	unlink(dna.file)#
#
	simenv.dna <- read.FASTA(sprintf("simulated/HIV_%d_out_TRUE.fas", i))#
	#simenv.dna <- read.dna(sprintf("simulated/HIV_SIM_%d.phy", i))#
	uid <- sample(1:length(names(simenv.dna)), length(names(simenv.dna)), replace=F)#
	# read.FASTA is buggy, and creates the DNABin structure incorrectly#
	# BUT, it's so broken that we can mess around with the names, then...#
	for(j in 1:length(names(simenv.dna))) { #
		# give each bin a unique name #
		names(simenv.dna)[j] <- sprintf("u%s_%s", uid[j], names(simenv.dna)[j])#
	}#
#
	# ... output a file (which works for some reason)#
	write.dna(simenv.dna, dna.file)#
	# and re-read it as a properly formatted DNA Bin#
	simenv.dna <- read.dna(dna.file)#
#
	tree <- raxml(simenv.dna, N=100, parsimony.seed=10000, bootstrap.seed=1000,threads=6)#
	write.tree(tree, sprintf("trees/HIV_ml_%d_out.nwk", i))#
#
	unlink(dna.file)#
	tree#
}#
#
trees.read <- function(base.path) {#
	ml.tree.read <- function(i, path){#
		read.tree(sprintf("%s/HIV_ml_%d_out.nwk", path, i))#
	}#
	mclapply(1:n.simulated, ml.tree.read, base.path)#
}#
#
hiv.rna.read <- function(){#
	trs <- dir('./7_ml_tree')[grep('_rna.nwk', dir('./7_ml_tree'))]#
	ml.tree.read <- function(tr) {#
		read.tree(paste('./7_ml_tree', tr, sep='/'))#
	}#
	lapply(trs, ml.tree.read)#
}#
#
trees <- mclapply(1:n.simulated, ml.tree, mc.cores=1)#
#trees <- hiv.rna.read()#
#trees <- trees.read("simulated/tree/")#
#
n.simulated <- length(trees)#
run_name <- "HIV RNA"#
species <- "Simulated"#
n.runs <- 100#
#
for(remove in c(1, 5, 10, 25)){#
	pdf(sprintf('%s_%d.pdf', run_name, remove), width=11.5, height=8.5)#
#
	mse <- rep(0, n.simulated*n.runs)#
	for(i in 1:n.simulated){#
		if(length(trees[[i]]$tip.label) <= remove) {#
			next#
		}#
		tip.dates <- extract_dates(trees[[i]]$tip.label)#
		r <- test.n.plot.rtt(trees[[i]], tip.dates, remove, name=sprintf("%s: %s-no.%d (Remove %d)", run_name, species, i, remove))#
		if(is.null(r)){#
			next#
		}#
		for(j in 1:n.runs) {#
			err  <- test.rtt(trees[[i]], tip.dates, remove)#
			if(!is.null(err)) {#
				mse[(j-1)*n.simulated + i] <- err#
			}#
		}#
	}#
#
	par(mfrow = c(1, 1))#
	mean_mse <- mean(mse)#
	hist(mse, breaks=100,  main="Histogram of MSE", sub=sprintf("(Average MSE [in red]: %s)", signif(mean_mse, digits=6)))#
	abline(v = mean_mse, col = "red", lwd = 2)#
	dev.off()#
}
